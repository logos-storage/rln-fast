
# === prover CLI ===

{. warning[UnusedImport]:off .}

import sugar
import std/strutils
import std/sequtils
import std/options
import std/random
import std/os
import std/parseopt

import taskpools

import constantine/named/properties_fields

import rln/types
import rln/json/bn254
import rln/gen_inputs
import rln/misc

import groth16/zkey_types
import groth16/files/zkey
import groth16/files/witness
import groth16/prover
import groth16/prover/shared
import groth16/prover/types
import groth16/partial/types
import groth16/partial/precalc
import groth16/partial/finish
import groth16/misc

import circom_witnessgen/types
import circom_witnessgen/input_json
import circom_witnessgen/graph
import circom_witnessgen/load
import circom_witnessgen/dependencies
import circom_witnessgen/witness
import circom_witnessgen/partial
import circom_witnessgen/export_wtns

#-------------------------------------------------------------------------------

type FullConfig = object
#  globCfg:     GlobalConfig
  inputFile:   string
  partialFile: string
  graphFile:   string
  zkeyFile:    string
  verbose:     bool

const defaultFullCfg =
  FullConfig( # globCfg:     defaultGlobalConfig
              inputFile:   ""
            , partialFile: ""
            , graphFile:   ""
            , zkeyFile:    ""
            , verbose:     false
            )

#-------------------------------------------------------------------------------

proc printHelp() =
  echo "usage:"
  echo "$ ./prover [options] --input=input.json --partial=partial.json"
  echo ""
  echo "available options:"
  echo " -h, --help                          : print this help"
  echo " -v, --verbose                       : verbose output (print the actual parameters)"
#  echo " -d, --merkle_depth = <depth>        : Merkle tree depth (default: 20)"
#  echo " -b, --limit_bits   = <bits>         : log2 of maximum number of messages per epoch (default: 16)"
  echo " -i, --input        = <input.json>   : the JSON file into which we write the full proof inputs"
  echo " -p, --partial      = <partial.json> : the JSON file into which we write the partial inputs"
  echo " -g, --graph        = <rln.graph>    : the witness computation graph file generated by `build-circuit`"
  echo " -z, --zkey         = <rln.zkey>     : the .zkey (prover and verifier keys) for the Groth16 circuit"
  echo ""

  quit()

#-------------------------------------------------------------------------------

proc parseCliOptions(): FullConfig =

  var globCfg = defaultGlobalConfig
  var fullCfg = defaultFullCfg

  var argCtr: int = 0
  for kind, key, value in getOpt():
    case kind

    # Positional arguments
    of cmdArgument:
      # echo ("arg #" & $argCtr & " = " & key)
      argCtr += 1

    # Switches
    of cmdLongOption, cmdShortOption:
      case key

      of "h", "help"          : printHelp()
      of "v", "verbose"       : fullCfg.verbose       = true
#      of "d", "merkle_depth"  : globCfg.merkle_depth  = parseInt(value) 
#      of "b", "limit_bits"    : globCfg.limit_bits    = parseInt(value)
      of "i", "input"         : fullCfg.inputFile     = value
      of "p", "partial"       : fullCfg.partialFile   = value
      of "g", "graph"         : fullCfg.graphFile     = value
      of "z", "zkey"          : fullCfg.zkeyFile      = value
      else:
        echo "Unknown option: ", key
        echo "use --help to get a list of options"
        quit()

    of cmdEnd:
      discard  

  # fullCfg.globCfg = globCfg
  
  return fullCfg

#-------------------------------------------------------------------------------

proc printConfig(fullCfg: FullConfig) =

  # let globCfg = fullCfg.globCfg

  # echo "field           = BN254"
  # echo "hash function   = Poseidon2"
  # echo "merkle_depth    = " & ($globCfg.merkle_depth)
  # echo "limit_bits      = " & ($globCfg.limit_bits)

  echo "full input file        = " & fullCfg.inputFile
  echo "partial input file     = " & fullCfg.partialFile
  echo "zkey file              = " & fullCfg.graphFile 
  echo "computation graph file = " & fullCfg.graphFile 

#-------------------------------------------------------------------------------

type
  XWitness        = seq[Fr[BN254_Snarks]]                # nim namespacing ......
  XPartialWitness = seq[Option[Fr[BN254_Snarks]]]        # .... is fucking stupid

when isMainModule:

  let fullCfg = parseCliOptions()
  # let globCfg = fullCfg.globCfg

  if fullCfg.verbose:
    printConfig(fullCfg)

  if fullCfg.zkeyFile == "" or fullCfg.inputFile == "" or fullCfg.partialFile == "" or fullCfg.graphFile == "":
    echo "nothing we can do!"
    echo "we require .zkey, computation graph, and partial and full input files for the circuit"
    echo "use --help for getting a list of options"
    quit()

  let nthreads = 1
  var pool = Taskpool.new(nthreads)

  let fullInput    : Inputs = loadInputJSON(fullCfg.inputFile  )
  let partialInput : Inputs = loadInputJSON(fullCfg.partialFile)
  let xzkey        : ZKey   =     parseZKey(fullCfg.zkeyFile   )    # fucking stupid nim puts the short"module" 
  let xgraph       : Graph  =     loadGraph(fullCfg.graphFile  )    # names in the same namespace as variables...

  let printFlag  = true
  let detailFlag = false

  var fullWitness1: XWitness
  withMeasureTime(printFlag, "generating full witness"):
    fullWitness1 = generateWitness(xgraph, fullInput)
  let fullWitness = makeWitnessBN254(fullWitness1)                   # Groth16's witness type is more complicated

  var partialWitness1: XPartialWitness
  withMeasureTime(printFlag, "generating partial witness"):
    partialWitness1 = generatePartialWitness(xgraph, partialInput)
  let partialWitness = makePartialWitness(partialWitness1)           # see above, same again
 
  let mask: Mask = randomMask()

  var fullProof: Proof
  withMeasureTime(printFlag, "generating full proof"):
    fullProof = generateProofWithMask(xzkey, fullWitness, mask, pool, detailFlag)

  var partialProof: PartialProof
  withMeasureTime(printFlag, "generating partial proof"):
    partialProof = generatePartialProof(xzkey, partialWitness, pool, detailFlag)

  var finishedProof: Proof
  withMeasureTime(printFlag, "finishing partial proof"):
    finishedProof = finishPartialProofWithMask(xzkey, fullWitness, partialProof, mask, pool, detailFlag)

  if isEqualProof(fullProof, finishedProof):
    echo "OK. the two proofs match"
  else:
    echo "PROBLEM! the two proofs differ!"

  echo "done"

